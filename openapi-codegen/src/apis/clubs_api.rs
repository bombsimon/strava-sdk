/*
 * Strava API v3
 *
 * The [Swagger Playground](https://developers.strava.com/playground) is the easiest way to familiarize yourself with the Strava API by submitting HTTP requests and observing the responses before you write any client code. It will show what a response will look like with different endpoints depending on the authorization scope you receive from your athletes. To use the Playground, go to https://www.strava.com/settings/api and change your “Authorization Callback Domain” to developers.strava.com. Please note, we only support Swagger 2.0. There is a known issue where you can only select one scope at a time. For more information, please check the section “client code” at https://developers.strava.com/docs.
 *
 * The version of the OpenAPI document: 3.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

/// struct for passing parameters to the method [`get_club_activities_by_id`]
#[derive(Clone, Debug)]
pub struct GetClubActivitiesByIdParams {
    /// The identifier of the club.
    pub id: i64,
    /// Page number. Defaults to 1.
    pub page: Option<i32>,
    /// Number of items per page. Defaults to 30.
    pub per_page: Option<i32>
}

/// struct for passing parameters to the method [`get_club_admins_by_id`]
#[derive(Clone, Debug)]
pub struct GetClubAdminsByIdParams {
    /// The identifier of the club.
    pub id: i64,
    /// Page number. Defaults to 1.
    pub page: Option<i32>,
    /// Number of items per page. Defaults to 30.
    pub per_page: Option<i32>
}

/// struct for passing parameters to the method [`get_club_by_id`]
#[derive(Clone, Debug)]
pub struct GetClubByIdParams {
    /// The identifier of the club.
    pub id: i64
}

/// struct for passing parameters to the method [`get_club_members_by_id`]
#[derive(Clone, Debug)]
pub struct GetClubMembersByIdParams {
    /// The identifier of the club.
    pub id: i64,
    /// Page number. Defaults to 1.
    pub page: Option<i32>,
    /// Number of items per page. Defaults to 30.
    pub per_page: Option<i32>
}

/// struct for passing parameters to the method [`get_logged_in_athlete_clubs`]
#[derive(Clone, Debug)]
pub struct GetLoggedInAthleteClubsParams {
    /// Page number. Defaults to 1.
    pub page: Option<i32>,
    /// Number of items per page. Defaults to 30.
    pub per_page: Option<i32>
}


/// struct for typed errors of method [`get_club_activities_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetClubActivitiesByIdError {
    DefaultResponse(models::Fault),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_club_admins_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetClubAdminsByIdError {
    DefaultResponse(models::Fault),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_club_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetClubByIdError {
    DefaultResponse(models::Fault),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_club_members_by_id`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetClubMembersByIdError {
    DefaultResponse(models::Fault),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_logged_in_athlete_clubs`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetLoggedInAthleteClubsError {
    DefaultResponse(models::Fault),
    UnknownValue(serde_json::Value),
}


/// Retrieve recent activities from members of a specific club. The authenticated athlete must belong to the requested club in order to hit this endpoint. Pagination is supported. Athlete profile visibility is respected for all activities.
pub async fn get_club_activities_by_id(configuration: &configuration::Configuration, params: GetClubActivitiesByIdParams) -> Result<Vec<models::ClubActivity>, Error<GetClubActivitiesByIdError>> {

    let uri_str = format!("{}/clubs/{id}/activities", configuration.base_path, id=params.id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ClubActivity&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ClubActivity&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetClubActivitiesByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a list of the administrators of a given club.
pub async fn get_club_admins_by_id(configuration: &configuration::Configuration, params: GetClubAdminsByIdParams) -> Result<Vec<models::SummaryAthlete>, Error<GetClubAdminsByIdError>> {

    let uri_str = format!("{}/clubs/{id}/admins", configuration.base_path, id=params.id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SummaryAthlete&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SummaryAthlete&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetClubAdminsByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a given club using its identifier.
pub async fn get_club_by_id(configuration: &configuration::Configuration, params: GetClubByIdParams) -> Result<models::DetailedClub, Error<GetClubByIdError>> {

    let uri_str = format!("{}/clubs/{id}", configuration.base_path, id=params.id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::DetailedClub`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::DetailedClub`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetClubByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a list of the athletes who are members of a given club.
pub async fn get_club_members_by_id(configuration: &configuration::Configuration, params: GetClubMembersByIdParams) -> Result<Vec<models::ClubAthlete>, Error<GetClubMembersByIdError>> {

    let uri_str = format!("{}/clubs/{id}/members", configuration.base_path, id=params.id);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::ClubAthlete&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::ClubAthlete&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetClubMembersByIdError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a list of the clubs whose membership includes the authenticated athlete.
pub async fn get_logged_in_athlete_clubs(configuration: &configuration::Configuration, params: GetLoggedInAthleteClubsParams) -> Result<Vec<models::SummaryClub>, Error<GetLoggedInAthleteClubsError>> {

    let uri_str = format!("{}/athlete/clubs", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.per_page {
        req_builder = req_builder.query(&[("per_page", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.oauth_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::SummaryClub&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::SummaryClub&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetLoggedInAthleteClubsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

